# 2026-02-16
Functional
    - Taking business rules/requirements and implementing and enforcing them in code (translating)

Operational
    - Our code running in production
    - Scaling, reliability, all that
    - "Runtime" vs "Development Time"
    - "Non-Functional"

Development
    - Maintaining source control
    - Pipelines
    - Training
    - Documentation

Testing
    - Old skool thinking was developers cannot have a local environment that replicates production so they can only write Unit Tests
        - Super low level, break encapsulation

DevOps
    - Observability - observing that code running in production
    - Feature Toggles - half and half? 
    - Servability
    - Pipelines

Feedback Loops
    - Cybernetics
    - Norbert Weiner
Steering wheel on a ship
    - Kubernetes

Inner Loop
    - The things that happen on our machine before we push our code
After we push - so the pipeline - and ultimately, production
    - I rarely test my code, but when I do it's in production (Joke)


Two "services" in our app
    - They are both in the same "assembly" - pros: can't ship code that doesn't compile
        - This is early bound
    - Go our separate ways, but in a "package", like a nuget package or NPM package or whatever
        - Still early bound
        - The creator of the package can "get ahead of us"
    - Making it external - "late bound"
        - The scariest, flakiest way possible. But we need to do it, sometimes


Some weird software paradox:
    - We can't build software, we have to grow it
    - There are a lot of catch-22, chicken or the egg things
        - I can't build the Angular app until the APIs are done
            - Which means the APIs will have to know what the Angular app is before the app is done
    - We make software out of small, focused things
        - Why?
        - Tests can only be written for small focused things
            - "Begging the question"
        - If you understand why small focused things, tests become a way to ensure you are doing that

- Unit Tests are tests that test a "Unit" of code in isolation for other dependencies that change so frequently, they may "break" our test
- "We can't call the account's deposit method witht he 'real' bonus calculator" because it was changing and annoying the heck out of us because our tests would fail
- HARD LINE for something to be a unit test is:
    - It cannot touch the network, the file system, a database, a config file, or the clock

Good practice: 
    1. Build
    2. Unit Tests (Very fast)
        - Tests part of the application but does not "prove" business-facing functionality
    3. System Tests
        - Proves business facing functionality
        - Isolated for backing services

- Unit Integration:
    - May touch file system, network, etc. but does not (yet) "prove" business facing functionality
- System Integration Test - Usually called something like "End to End (E2E) test"
    - Don't really prove much that's important except the most important thing

What is something very complex?
    - Algorithmically - Like lots of if, else, loops, etc. More data structures. Thing string calculator. But multiply that times... a bunch
    - "VIN Validator"
    - "Lunh/Mod 10" for credit card numbers

- Dummies
- Stubs
- Mocks
- Fakes - "Real things, but not **really real**"

Smoke Tests:
    - Just making sure we have the configuration right

David Fowler - Created ASP.NET Core

System Integration (End to End) tests TEND to be "black box tests"
    - Use other testing tools/languages than the system they are testing
    - Playwright - browser automation testing tool - Use typescript (Can use C#)

DOTNET is almost unique in this. It has a thing between these. This is called "gray box testing"
    - System Tests
        - Let's us peer under the rug when we have to make sure these other things (side-effects) are happening
    - We can host them in our tests

Unit Tests and Unit Integration tests are "white box tests"
    - "Clear box" - These tests are written in the same language as the system under test, they have a reference to the assembly, create instances of classes, call methods
    - They know "how the bread is buttered" so to speak, how the sausage is made
    - In other words, they break encapsulation