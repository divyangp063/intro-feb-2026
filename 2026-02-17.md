# 2026-02-17

This is about:
- Testing. How do we "simulate and verify" the behavior of our code
    - Sometimes we have to "simulate and verify" things that don't even exist yet
    - The need for a bonus calculator didn't appear at the beginning in our "requirements gathering phase" or whatever, it was "the business wants this BEHAVIOR, and our job is to make it so in code"
- Testing is
    - Does the thing work right?
    - Verifying the business worthiness of something
    - "does the thing right" - subjective - We are trying to write code that has some qualities to it. Not all code is equal
    - Expresses interest, fewest number of elements, duplication - "moist" or "rug" is best. 
    - Reusable - Not as common as we think. We aren't (usually) library or framework developers
        - But we reuse "concepts" not "code" - for example, there is a HUGE difference between copying the following code into a new location:
    
```csharp
public void Deposit(decimal amount)
{
    if(amount <= 0)
    {
        throw new InvalidTransactionAmountException();
    }
    _balance += amount;
}
```
And our identifying a "concept" that is expressed by that `if` statement, which we labeled `TransactionAmount` - we can reuse THAT

- LOOSE COUPLING
    - Coupling is the "strength of relationships between code modules"
    - The ability to change one thing without breaking another
    - Changing implemention without changing the interface
    - You have to DESIGN software this way. It isn't natural. We have to do it intentionally
- Write out code as if we are super skeptical that we or anybody else knows what the hell we are actually doing
    - Because we don't often - things change over time. Bonuses get calculated differently later than they do now
        - We need to assume our stuff is going to change, and we want to minimize the "infected radius"

- "Hypothesis Driven Development"
    - What we can do, nobody else can do
    - "Cool story bro, what are a couple things we cna do soon to see if this is something we want to invest in?"


### Environments:
- Local Development -> Identity Provider (IDP), Shared DEV Database, Shared Backing Services ("Responders")
    - Instead of going out, use Fake services (Fake DB - Postgres, Fake IDP)
- Local Test (Pipeline)
- Production
    - If you write to a logger, and you get an exception, send it to an IWebService (TDD Kata 2)
    Chaos Monkey - Testing the limits of the code! LITERALLY ANYTHING. "It will happen. We will make it happen!"


### Node and Versions
    - Node Version Manager (nvm) [Mostly Used here]
    - Volta
    - Mise (Mise en sense)
        - Big league package manager (nix, nix flakes)


### Angular
    - Angular is a Framework, which is a way of saying "It's angular's world, we just code in it", as opposed to a library, which is like "I'm here if you need me"
    - Why is it good?
        - Straight and forward
        - "App" - One project is one app
            <app-root>{}</app-root>
        - Component - Some code and a template that is responsible for an area of user interface
            - The parent of a component can "hand" some data to component as an "input"
            - A component can send a message to the parent, with or without data as an "output"
        - Services - Things that own some state and the process associated with that state and can be used across the application or a feature (such as login info state)
        - Pipes - Formatters - 3.99 ==> $3.99
        - Directives - Ways to "add in" functionality on elements or components
            - Sort of like "mix-ins" or prototypes